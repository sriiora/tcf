#! /usr/bin/python2
# coding:utf-8
#
# Copyright (c) 2017 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
#

"""
Test Target Broker Daemon

.. admonition:: FIXME

   How do we get the help screen auto-extracted?

Authentication
--------------

FIXME: write up in progress

"""

import commonl.requirements

# Verify that we can run TTBD
commonl.requirements.verify_python_version()
commonl.requirements.verify_flask_version()

# FIXME: diagnostics returning can be significant to load in memory; a
# generator must be put in place; we must log to a temporary file and
# then stream it see
# https://blog.al4.co.nz/2016/01/streaming-json-with-flask/

import base64
import ttbl.cm_logger
import codecs
import contextlib
import cPickle
import datetime
import errno
import signal
import threading
import ttblc
import ttbl.user_control
import os
import multiprocessing
import hashlib
import ssl
import werkzeug
import werkzeug.serving
import flask
# Change from flask 0.10 -> 0.11
try:
    import flask_login
    import flask_principal
except ImportError as e:
    import flask.ext.login as flask_login
    import flask.ext.principal as flask_principal
import StringIO
import ttbl
import traceback
import argparse
import re
import pprint
import tempfile
import time
import commonl
import ttbl.config
import requests
import shutil
import sys
reload(sys)
# change the default string encoding to ASCII to remove the mess of encodings
# this is currently a controversial hack and with Py3 it will dissapear
sys.setdefaultencoding('utf-8')
import urlparse
import glob

#import prctl

# Run the encoding on UTF-8; sometimes when started in background
# Python gets confused about what is the default encoding.
reload(sys)	# need this reload to get setdefaultencoding()
sys.setdefaultencoding('utf8')

try:
    import sdnotify
    sd_notify = sdnotify.SystemdNotifier()
    systemd_available = True
except ImportError as e:
    class fake_SystemdNotifier(object):
        def notify(self, state):
            pass
    sd_notify = fake_SystemdNotifier()
    systemd_available = False

# I bet there is a better way to do this...but we need the symbol to
# be in the logging module so that it is not included in the "function
# that called this" by the logging's internals.
# For debugging, levels are D2: 9, D3: 8, D4:7 ...
import logging
# FIXME: trick -- change function.f_code to match logging.root.critical.f_code
# FIXME: log* functions not working right, no output printed. tf?
setattr(logging, "logc", logging.root.critical)
setattr(logging, "logx", logging.root.exception)
setattr(logging, "loge", logging.root.error)
setattr(logging, "logw", logging.root.warning)
setattr(logging, "logi", logging.root.info)
setattr(logging, "logd", logging.root.debug)
setattr(logging, "logdl", logging.root.log)
from logging import logc, loge, logx, logw, logi, logd, logdl

app = flask.Flask(__name__)
API_VERSION = 1
API_PATH = "/ttb-v"
API_PREFIX = API_PATH + str(API_VERSION) + "/"

codec_utf8 = codecs.lookup("utf8")

# FIXME: these three likely doesn't need to be global -- we can move
# to init_app()
#  We are not really using these decorators...yet.
#admin_permission = flask_principal.Permission(
#    flask_principal.RoleNeed('admin'))
#user_permission = flask_principal.Permission(
#    flask_principal.RoleNeed('user'))

def flask_loge_abort(http_code, *args, **kwargs):
    loge(*args, **kwargs)
    flask.abort(http_code, *args)

def flask_logw_abort(http_code, *args, **kwargs):
    logw(*args, **kwargs)
    flask.abort(http_code, *args)

def flask_logi_abort(http_code, *args, **kwargs):
    logi(*args, **kwargs)
    flask.abort(http_code, *args)

def flask_logd_abort(http_code, *args, **kwargs):
    logd(*args, **kwargs)
    flask.abort(http_code, *args)

def flask_log_abort(l, http_code, *args, **kwargs):
    logdl(l, *args, **kwargs)
    flask.abort(http_code, *args)


#
# FIXME: Can't figure out a way how to just handle all with this one,
# so I need to link each
#
@app.errorhandler(400)
@app.errorhandler(404)
#@app.errorhandler(423)
def _error_handler(error):
    r = flask.make_response(flask.jsonify({ 'message': error.description }))
    r.status_code = error.code
    return r

def _target_id_to_dict(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    r = {
        'id': target_id,
        'type': target.type,
        'owner': target.owner_get(),
    }
    # Export a properties
    for prop in target.fsdb.keys():
        r[prop] = target.fsdb.get(prop)
    # Override a few standard properties
    r['disabled'] = target.fsdb.get('disabled') == "True"
    if isinstance(target, ttbl.tt_power_control_mixin):
        # Use the cached version, otherwise it takes too long
        r['powered'] = target.fsdb.get('powered') != None
    r.update(target.tags)
    # Make the interfaces list a space separated string
    r['interfaces_names'] = " ".join(target.tags['interfaces'])
    return r


@contextlib.contextmanager
def log_to_str_too(logger, io):
    """
    Context manager to add a handler to a logger and then remove it upon exit

    This is used to add a temporary string handler that makes a copy
    of the logs generated by an operation in a target and then send it
    as diagnostics with the HTML response to the client.
    """

    # logger.logger? Yup, we are passed a logadapter, we want to  the
    # actual logger object to set handlers
    lh = logging.StreamHandler(io)
    try:
        logger.logger.addHandler(lh)
        yield
    finally:
        logger.logger.removeHandler(lh)

def who_make(ticket = None, user = None):
    # current user is going to be a ttbl.user_control.User object; the
    # convention across this daemon (see
    # ttbl.user_control.who_is_admin) is that we name owners of
    # resources USERNAME[:TICKET].
    #
    # see ttbl.who_split()
    if user == None:
        user = flask_login.current_user
    else:
        assert isinstance(user, ttbl.user_control.User)
    return ttbl.who_create(user.get_id(), ticket)

def current_user_is_admin():
    """
    Evaluate if the current user, is an admin
    """
    user = flask_login.current_user
    if user:
        return user.is_admin()
    return False

@app.route(API_PREFIX + 'login', methods = ['PUT'])
def login():
    """
    Given a User ID token and a password, go over all the
    authentication mechanisms that we have defined and see who can
    authenticate it.
    """
    email = flask.request.form.get('email', None)
    if email == None:
        return flask.abort(404, "missing user ID")
    password = flask.request.form.get('password', None)

    user = flask_login.current_user
    user_id = user.get_id()
    logd("user %s: trying to authenticate with token '%s'" % (user_id, email))

    if isinstance(user, ttbl.user_control.User) \
       and user.get_id() == email \
       and user.is_authenticated():
        logi("user %s: authenticated, has a valid session" % user_id)
        return True

    # Go over all the configured authentication mechanisms and try to
    # obtain roles that this combination of email/password allows us
    # Each authenticator might plug us to LDAP, or to a local
    # database...who knows
    token_roles = set()
    message = ""
    for authenticator in ttbl.config._authenticators:
        try:
            logd("user %s: authenticating  with %s" % (email, authenticator))
            _token_roles = authenticator.login(
                email, password,
                remote_address = flask.request.remote_addr)
            logi("user %s: authenticated  with %s: roles %s"
                 % (email, authenticator, _token_roles))
            token_roles.update(_token_roles)
            break
        except ttbl.authenticator_c.invalid_credentials_e as e:
            logi("user %s: invalid credentials from %s: %s"
                 % (email, authenticator, e))
            pass
        except ttbl.authenticator_c.unknown_user_e as e:
            logi("user %s: unknown user to '%s'" % (email, authenticator))
            pass
        except Exception as e:
            logi("user %s: auth error with %s: %s" % (email, authenticator, e))
            logx(e)
            pass
            # Try next authenticator

    if not 'user' in token_roles:
        logi("user %s: not allowed, no 'user' role (just %s)"
             % (email, list(token_roles)))
        flask.abort(404, "user %s: not allowed, no 'user' role: %s"
                    % (email, message))

    # Now let's go ahead and make sure there is a user instance that
    # Flask understands
    if not user or not isinstance(user, ttbl.user_control.User):
        user = ttbl.user_control.User(email)
        if 'admin' in token_roles:
            user.set_role('admin')
        flask_login.login_user(user, remember = True)
        flask_principal.identity_changed.send(
            flask.current_app._get_current_object(),
            identity = flask_principal.Identity(user.get_id()))
    elif 'admin' in token_roles:
        user.set_role('admin')

    logi("user %s: authenticated with roles %s" % (email, list(token_roles)))
    return flask.jsonify({'login': "user %s: authenticated with roles %s"
                          % (email, list(token_roles))})

@app.route(API_PREFIX + 'logout', methods = ['GET'])
@flask_login.login_required
def logout():
    flask_login.logout_user()
    for key in ('identity.name', 'identity.auth_type'):
        flask.session.pop(key, None)
        flask_principal.identity_changed.send(
            flask.current_app._get_current_object(),
            identity = flask_principal.AnonymousIdentity())
    return flask.jsonify({'ok': "Session closed"})

@app.route(API_PREFIX + "validate_session", methods = ['GET'])
@flask_login.login_required
def validate_session():
    return flask.jsonify({'status': "You have a valid session"})

@app.route(API_PREFIX + 'targets/', methods = ['GET'])
@flask_login.login_required
def _targets_gets():
    _list = []
    for target_id in ttbl.config.targets.keys():
        try:
            _list.append(_target_id_to_dict(target_id))
        except Exception as e:
            loge("%s: error listing target: %s\n%s\n"
                 % (target_id, e, traceback.format_exc()))
            _list.append(dict(id = target_id, owner = "error"))
    return flask.jsonify({'targets': _list})


@app.route(API_PREFIX + 'targets/<string:target_id>', methods = ['GET'])
@flask_login.login_required
def _targets_get(target_id):
    if target_id not in ttbl.config.targets.keys():
        flask.abort(404, "%s: can't find target" % target_id)
    else:
        _list = [_target_id_to_dict(target_id)]
    return flask.jsonify({'targets': _list})


@app.route(API_PREFIX + 'targets/<string:target_id>/acquire', methods = ['PUT'])
@flask_login.login_required
def _target_acquire(target_id):
    # a valid user can try to acquire multiple times (it's a PUT request after all) and it
    # would succeed if already acquired.
    # FIXME: some security checks on this ticket?
    ticket = flask.request.form.get('ticket', "")
    if flask.request.form.get('force', 'false').lower() == 'true':
        force = True
        if not current_user_is_admin():
            flask_logd_abort(400, "forced acquisition requires admin rights")
    else:
        force = False

    if target_id not in ttbl.config.targets.keys():
        return flask.abort(404, "%s: can't find target" % target_id)
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    try:
        target.acquire(who_make(ticket), force)
        target.timestamp()
    except ttbl.test_target_busy_e as e:
        flask_log_abort(3, 400, "%s" % e, exc_info = False)
    except ttbl.test_target_e as e:
        # Not considered as errors, no traces printed -- as these are
        # normal during operation.
        flask_logd_abort(400, "%s" % e, exc_info = False)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    r = _target_id_to_dict(target_id)
    return flask.jsonify(_target_id_to_dict(target_id))


@app.route(API_PREFIX + 'targets/<string:target_id>/active', methods = ['PUT'])
@flask_login.login_required
def _target_active(target_id):
    """
    If this target is owned by the caller, mark it as active
    """
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    try:
        if who_make(ticket) == target.owner_get():
            # when this is the owner, this marks the target as active
            target.timestamp()
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({})


@app.route(API_PREFIX + 'targets/<string:target_id>/disable', methods = ['PUT'])
@flask_login.login_required
def _target_disable(target_id):
    ticket = flask.request.form.get('ticket', "")
    if not current_user_is_admin():
        raise ttbl.test_target_not_admin_e(target)
    if target_id not in ttbl.config.targets.keys():
        return flask.abort(404, "%s: can't find target" % target_id)
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    try:
        target.disable(who_make(ticket))
        target.timestamp()
    except ttbl.test_target_busy_e as e:
        flask_log_abort(3, 400, "%s" % e, exc_info = False)
    except ttbl.test_target_e as e:
        # Not considered as errors, no traces printed -- as these are
        # normal during operation.
        flask_logd_abort(400, "%s" % e, exc_info = False)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    r = _target_id_to_dict(target_id)
    return flask.jsonify(_target_id_to_dict(target_id))

@app.route(API_PREFIX + 'targets/<string:target_id>/enable', methods = ['PUT'])
@flask_login.login_required
def _target_enable(target_id):
    ticket = flask.request.form.get('ticket', "")
    if target_id not in ttbl.config.targets.keys():
        return flask.abort(404, "%s: can't find target" % target_id)
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    if not current_user_is_admin():
        raise ttbl.test_target_not_admin_e(target)
    try:
        target.enable(who_make(ticket))
        target.timestamp()
    except ttbl.test_target_busy_e as e:
        flask_log_abort(3, 400, "%s" % e, exc_info = False)
    except ttbl.test_target_e as e:
        # Not considered as errors, no traces printed -- as these are
        # normal during operation.
        flask_logd_abort(400, "%s" % e, exc_info = False)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    r = _target_id_to_dict(target_id)
    return flask.jsonify(_target_id_to_dict(target_id))


@app.route(API_PREFIX + 'targets/<string:target_id>/release', methods = ['PUT'])
@flask_login.login_required
def _target_release(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    if flask.request.form.get('force', 'false').lower() == 'true':
        force = True
    else:
        force = False

    # FIXME: some security checks on this ticket?
    ticket = flask.request.form.get('ticket', "")
    try:
        who = who_make(ticket)
        if force and not current_user_is_admin():
            raise ttbl.test_target_not_admin_e(target)
        target.release(who, force)
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({})


@app.route(API_PREFIX + 'targets/<string:target_id>/property_set',
           methods = ['PUT'])
@flask_login.login_required
def _property_set(target_id):
    # FIXME: we need a way to disable this command selectively
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    prop = flask.request.form.get('property', "")
    user_is_admin = current_user_is_admin()
    value = flask.request.form.get('value', None)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        info = ""
        with log_to_str_too(target.log, iostr_wrapper):
            if user_is_admin:
                target.property_set(prop, value)
            elif not target.property_is_user(prop):
                raise ttbl.test_target_not_admin_e(target)
            else:
                # A non-admin must own the target before setting anything
                target.property_set_locked(who_make(ticket), prop, value)
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({
        'diagnostics': iostr.getvalue()
    })


@app.route(API_PREFIX + 'targets/<string:target_id>/property_get',
           methods = ['PUT'])
@flask_login.login_required
def _property_get(target_id):
    # FIXME: we need a way to disable this command selectively
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    prop = flask.request.form.get('property', "")
    user_is_admin = current_user_is_admin()
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        info = ""
        with log_to_str_too(target.log, iostr_wrapper):
            if user_is_admin:
                value = target.property_get(prop)
            elif not target.property_is_user(prop):
                raise ttbl.test_target_not_admin_e(target)
            else:
                # A non-admin must own the target before getting anything
                value = target.property_get_locked(who_make(ticket), prop)
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({
        'value' : value,
        'diagnostics': iostr.getvalue()
    })

@app.route(API_PREFIX + 'targets/<string:target_id>/thing',
           methods = ['PUT', 'GET', 'DELETE'])
@flask_login.login_required
def _thing(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        r = {}
        with log_to_str_too(target.log, iostr_wrapper):
            if flask.request.method == "PUT":
                if not 'thing' in flask.request.form:
                    return flask.abort(404, "missing 'thing' paramter")
                thing = flask.request.form['thing']
                target.thing_plug(who_make(ticket), thing)
                target.timestamp()	# If this works, it is acquired and locked
            elif flask.request.method == "DELETE":
                if not 'thing' in flask.request.form:
                    return flask.abort(404, "missing 'thing' paramter")
                thing = flask.request.form['thing']
                target.thing_unplug(who_make(ticket), thing)
                target.timestamp()	# If this works, it is acquired and locked
            elif flask.request.method == "GET":
                r['result'] = target.thing_list(who_make(ticket))
                target.timestamp()	# If this works, it is acquired and locked
            else:
                flask_logi_abort(400, "Unupported request %s" % method)
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    finally:
        r['diagnostics'] = iostr.getvalue()
    return flask.jsonify(r)


# FIXME: this is a pattern, use a decorator?
@app.route(API_PREFIX + 'targets/<string:target_id>/power_on', methods = ['PUT'])
@flask_login.login_required
def _target_power_on(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_power_control_mixin):
        return flask.abort(400, "%s: target does not implement power control interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.power_on(who_make(ticket))
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/power_off', methods = ['PUT'])
@flask_login.login_required
def _target_power_off(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_power_control_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "power control interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.power_off(who_make(ticket))
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/reset',
           methods = ['PUT'])
@flask_login.login_required
def _target_reset(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_power_control_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "power control interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.reset(who_make(ticket))
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/power_cycle',
           methods = ['PUT'])
@flask_login.login_required
def _target_power_cycle(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if 'wait' in flask.request.form:
        wait = float(flask.request.form['wait'])
    else:
        wait = None
    if not isinstance(target, ttbl.tt_power_control_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "power control interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.power_cycle(who_make(ticket), wait)
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/power_get',
           methods = ['GET'])
@flask_login.login_required
def _target_power_get(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    if not isinstance(target, ttbl.tt_power_control_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "power control interface" % target_id)
    try:
        powered = target.power_get()
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'powered': powered })


def tb_file_local_path_get(username, filepath):
    """
    Verify the *image_name* is available in the target broker's
    storage for the current *username* and return it's local file
    path.
    """
    local_filepath = os.path.normpath("%s/%s/%s" % (
        app.config['files_path'], username, filepath))
    if not os.path.isfile(local_filepath):
        return None
    else:
        return local_filepath

@app.route(API_PREFIX + 'targets/<string:target_id>/images_set',
           methods = ['PUT'])
@flask_login.login_required
def _target_images_set(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.test_target_images_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "image management interface" % target_id)
    images = {}
    ticket = ""
    for t, n in flask.request.form.items():
        if t == 'ticket':
            # FIXME: this is heck dirty, reimplement this call's
            # signature splitting args better
            ticket = n
            continue
        l = tb_file_local_path_get(flask_login.current_user.get_id(), n)
        if l == None:
            return flask.abort(400, "%s: file does not exist in broker" % n)
        images[t] = l
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.images_set(who_make(ticket), images)
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })


@app.route(API_PREFIX + 'targets/<string:target_id>/ip_tunnel',
           methods = [ 'POST', 'DELETE', 'GET' ])
@flask_login.login_required
def _target_ip_tunnel(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    # These are only used for POST/DELETE
    ip_addr = flask.request.form.get('ip_addr', None)
    ports = flask.request.form.get('port', None)
    proto = flask.request.form.get('proto', None)
    try:
        if flask.request.method == "POST":
            port = int(ports)
            local_port = target.ip_tunnel_add(who_make(ticket),
                                              ip_addr, port, proto)
            r = dict(port = local_port)
        elif flask.request.method == "DELETE":
            port = int(ports)
            target.ip_tunnel_remove(who_make(ticket), ip_addr, port, proto)
            r = dict()
        elif flask.request.method == "GET":
            tunnels = target.ip_tunnel_list(who_make(ticket))
            r = dict(tunnels = tunnels)
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify(r)


@app.route(API_PREFIX + 'targets/<string:target_id>/' \
           + '<string:interface>/<string:call>',
           methods = [ 'PUT', 'POST', 'DELETE', 'GET' ])
@flask_login.login_required
def _target_interface(target_id, interface, call):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader,
        codec_utf8.streamwriter, errors = 'replace')
    try:
        if not interface in target.tags['interfaces']:
            flask_logi_abort(400, "%s: unavailable interface" % interface)
        iface = getattr(target, interface, None)
        if iface == None:
            flask_logi_abort(400, "%s: interface broken" % interface)
        assert isinstance(iface, ttbl.tt_interface)
        username = flask_login.current_user.get_id()
        user_path = os.path.join(app.config['files_path'], username)
        with log_to_str_too(target.log, iostr_wrapper):
            method_name = flask.request.method.lower() + "_" + call
            method = getattr(iface, method_name, None)
            if method:
                result = method(target, who_make(ticket),
                                flask.request.form, user_path)
                iface.assert_return_type(
                    result, dict, target,
                    flask.request.form.get('component', None),
                    method_name, none_ok = False)
            else:
                result = iface.request_process(target, who_make(ticket),
                                               flask.request.method,
                                               call, flask.request.form,
                                               user_path)
        assert isinstance(result, dict), \
            "BUG: %s: request_process() did not return a dictionary" \
            " but a %s" \
            % (interface, type(result).__name__)
        if 'diagnostics' in result:
            target.log.error("BUG: %s: request_process() added a "
                             "'diagnostics' field that will be overriden"
                             % interface)
        result['diagnostics'] = iostr.getvalue()
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    if 'stream_file' in result:
        offset = result.get('stream_offset', 0)
        filepath = result['stream_file']
        try:
            fd = open(filepath, "rb")
            if offset > 0:
                fd.seek(offset)
        except Exception as e:
            flask_logi_abort(400, "%s: can't stream file: %s" % (filepath, e), exc_info = True)
        return flask.Response(fd, direct_passthrough = True)
    else:
        return flask.jsonify(result)


# FIXME: rewrite to pass the data in the body as a binary sequence
# (like read does) to remove file size limitations. This will require
# a protocol roll up or a new call.
@app.route(API_PREFIX + 'targets/<string:target_id>/console/',
           methods = ['GET'])
@flask_login.login_required
def _target_console_read(target_id, console = None):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.test_target_console_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "console interface" % target_id)
    console = flask.request.form.get('console', None)
    if 'offset' in flask.request.form:
        offset = int(flask.request.form['offset'])
    else:
        offset = 0
    try:
        g = target.console_read(who_make(ticket), console, offset)
        if who_make(ticket) == target.owner_get():
            # when this is the owner, this marks the target as active
            target.timestamp()
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.Response(g, direct_passthrough = True)


@app.route(API_PREFIX + 'targets/<string:target_id>/console_size',
           methods = ['GET'])
@flask_login.login_required
def _target_console_size(target_id, console = None):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.test_target_console_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "console interface" % target_id)
    console = flask.request.form.get('console', None)
    try:
        byte_count = target.console_size(who_make(ticket), console)
        if who_make(ticket) == target.owner_get():
            # when this is the owner, this marks the target as active
            target.timestamp()
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify(dict(byte_count = byte_count))


@app.route(API_PREFIX + 'targets/<string:target_id>/console/',
           methods = ['POST'])
@flask_login.login_required
def _target_console_write(target_id, console = None):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.test_target_console_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "console interface" % target_id)
    console = flask.request.form.get('console', None)
    data = flask.request.form.get('data')
    try:
        target.console_write(who_make(ticket), data, console)
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({})


@app.route(API_PREFIX + 'targets/<string:target_id>/debug',
           methods = ['PUT', 'GET', 'DELETE'])
@flask_login.login_required
def _debug(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_debug_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "debug interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        info = ""
        with log_to_str_too(target.log, iostr_wrapper):
            if flask.request.method == "PUT":
                target.debug_start(who_make(ticket))
                target.timestamp()	# If this works, it is acquired and locked
            elif flask.request.method == "DELETE":
                target.debug_stop(who_make(ticket))
                target.timestamp()	# If this works, it is acquired and locked
            elif flask.request.method == "GET":
                info = target.debug_info(who_make(ticket))
            else:
                flask_logi_abort(400, "Unupported request %s" % method)
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'info' : info, 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/debug_reset',
           methods = ['PUT'])
@flask_login.login_required
def _target_debug_reset(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_debug_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "debug interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.debug_reset(who_make(ticket))
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/debug_reset_halt',
           methods = ['PUT'])
@flask_login.login_required
def _target_debug_reset_halt(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_debug_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "debug interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.debug_reset_halt(who_make(ticket))
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/debug_halt',
           methods = ['PUT'])
@flask_login.login_required
def _target_debug_halt(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_debug_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "debug interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.debug_halt(who_make(ticket))
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })

@app.route(API_PREFIX + 'targets/<string:target_id>/debug_resume',
           methods = ['PUT'])
@flask_login.login_required
def _target_debug_resume(target_id):
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_debug_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "debug interface" % target_id)
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        with log_to_str_too(target.log, iostr_wrapper):
            target.debug_resume(who_make(ticket))
        target.timestamp()	# If this works, it is acquired and locked
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({ 'diagnostics': iostr.getvalue() })


@app.route(API_PREFIX + 'targets/<string:target_id>/debug_openocd',
           methods = ['PUT'])
@flask_login.login_required
def _debug_openocd(target_id):
    # FIXME: we need a way to disable this command selectively
    with ttbl.config.targets_lock:
        target = ttbl.config.targets[target_id]
    ticket = flask.request.form.get('ticket', "")
    if not isinstance(target, ttbl.tt_debug_mixin):
        return flask.abort(400, "%s: target does not implement the "
                           "debug interface" % target_id)
    command = flask.request.form.get('command', "")
    # See FIXME at file reader about diagnostics
    iostr = StringIO.StringIO()
    iostr_wrapper = codecs.StreamReaderWriter(
        iostr, codec_utf8.streamreader, codec_utf8.streamwriter, errors = 'replace')
    try:
        info = ""
        with log_to_str_too(target.log, iostr_wrapper):
            openocd_output = target.debug_openocd(who_make(ticket), command)
    except ttbl.test_target_e as e:
        flask_logi_abort(400, "%s" % e, exc_info = True)
    except Exception as e:
        flask_logi_abort(400, "%s: %s" % (target_id, e), exc_info = True)
    return flask.jsonify({
        'openocd_output' : openocd_output,
        'diagnostics': iostr.getvalue()
    })

# catch any '../something', 'something/../something', "something/.."
_bad_path = re.compile("(^\.\.$|^\.\./|/\.\./|/\.\.$)")

@app.route(API_PREFIX + 'files/<path:filepath>', methods = [ 'POST' ])
@flask_login.login_required
def _file_upload(filepath):
    """
    filepath is stored in $args['files_path']/USERNAME/filepath,
    overwriting whatever is there.
    """
    file = flask.request.files['file']
    if filepath == None:
        return flask.abort(400, "no destination path specified")
    if file:
        filepath_normalized = os.path.normpath(filepath)
        matches = _bad_path.findall(filepath)
        if matches:
            flask_logi_abort(400, "%s: file path cannot contains components: "
                             "%s" % (filepath, " ".join(matches)))
        path = os.path.dirname(filepath)
        userid = flask_login.current_user.get_id()
        if path != "":
            userdir = os.path.join(app.config['files_path'], userid, path)
        else:
            userdir = os.path.join(app.config['files_path'], userid)
        filepath_final = os.path.join(
            app.config['files_path'], userid, filepath_normalized)
        try:
            ttbl.test_target._user_files_create(userid)
            file.save(filepath_final)
        except Exception as e:
            return flask.abort(400, "%s: can't save: %s" % (filepath, e))
        logd("%s: saved" % filepath_final)
        return flask.jsonify({})

@app.route(API_PREFIX + 'files/<path:filepath>', methods = [ 'GET' ])
@flask_login.login_required
def _file_dnload(filepath):
    # Download file (streaming it) from the broker user's file storage area
    if filepath == None:
        return flask.abort(400, "no source path specified")
    filepath_normalized = os.path.normpath(filepath)
    matches = _bad_path.findall(filepath)
    if matches:
        flask_logi_abort(400, "%s: file path cannot contains components: "
                         "%s" % (filepath, " ".join(matches)))
    userid = flask_login.current_user.get_id()
    final_path = os.path.join(app.config['files_path'], userid,
                              filepath_normalized)
    try:
        fd = open(final_path, "rb")
    except Exception as e:
        flask_logi_abort(400, "%s: can't dnload: %s" % (filepath, e))
    return flask.Response(fd, direct_passthrough = True)

@app.route(API_PREFIX + 'files/<path:filepath>', methods = [ 'DELETE' ])
@flask_login.login_required
def _file_delete(filepath):
    """
    Remove the specified file from $args['files_path']/USERNAME/filepath.
    """
    if filepath == None:
        flask_logi_abort(400, "no file name specified")
    matches = _bad_path.findall(filepath)
    if matches:
        flask_logi_abort(400, "%s: file path cannot contains components: "
                         "%s" % (filepath, " ".join(matches)))
    try:
        filepath_local = os.path.join(app.config['files_path'],
                                      flask_login.current_user.get_id(),
                                      filepath)
        commonl.rm_f(filepath_local)
    except Exception as e:
        flask_logi_abort(400, "%s: can't remove: %s" % (filepath, e))
    return flask.jsonify({})


@app.route(API_PREFIX + 'files/', methods = [ 'GET' ])
@flask_login.login_required
def _files_list():
    """
    List all files available to the user
    """
    files = {}
    prefix_path = os.path.join("%s/%s" % (
            app.config['files_path'], flask_login.current_user.get_id()))
    for path, dirnames, filenames in os.walk(prefix_path):
        for filename in filenames:
            file_path = path + "/" + filename
            h = hashlib.sha256()
            commonl.hash_file(h, file_path)
            files[file_path[len(prefix_path) + 1:]] = h.hexdigest()
    return flask.jsonify(files)

@contextlib.contextmanager
def target_acquired(target, who):
    try:
        target.acquire(who, False)
        yield
    except:
        # do not force releasing it if we don't own it
        target.release(who, False)
        raise
    target.release(who, False)

def _do_cleanup_released(target, who):
    if not hasattr(target, "power_off"):	# Only with power control
        return
    if not target.power_rail_get_any():		# Is it off? pass
        return
    with target_acquired(target, who):	# Acquire, check idleness
        idle_time = time.time() - target.timestamp_get()
        idle_poweroff = target.tags.get('idle_poweroff',
                                        ttbl.config.target_max_idle)
        if idle_poweroff == 0:
            target.log.debug("skiping powering off, idle_poweroff is 0")
        elif target.power_rail_get_any and idle_time > idle_poweroff:
            target.log.info("powering off, idle for %.2fs (max %s)",
                            idle_time, idle_poweroff)
            target.power_off(who)

def _do_cleanup_acquired(target, owner, who):
        idle_time = time.time() - target.timestamp_get()
        if idle_time > ttbl.config.target_owned_max_idle:
            target.log.warning("releasing from %s, idle for %.2fs (max %s)",
                               owner, idle_time, ttbl.config.target_owned_max_idle)
            target.release(who, True)

def cleanup_files():
    for f in glob.iglob(app.config['files_path'] + "/*/*"):
       if (time.time() - os.stat(f).st_mtime ) > ttbl.config.cleanup_files_maxage:
               os.remove(f)

# Notify systemd we are alive
#
# Note we do this from two places: the beginning of the cleanup
# process in _cleanup_process_fn() and then inside _do_cleanup() for
# each thread.
#
# Why? because querying each target might be lengthy as we have to
# access the hardware and it might take time. So on each iteration, we
# do a keepalive if we have to.

_systemd_watchdog_period = None

def _systemd_keepalive(t):
    global _systemd_watchdog_period
    if _systemd_watchdog_period == None:
        return
    # We keepalive whenever we can
    sd_notify.notify("WATCHDOG=1")

def _do_cleanup():
    """
    """
    daemon_user = ttbl.user_control.local_user()
    target_list = ttbl.config.targets.keys()
    who = who_make("cleanup", user = daemon_user)
    for target_id in target_list:
        with ttbl.config.targets_lock:
            target = ttbl.config.targets[target_id]
        try:
            now = time.time()
            if target.tags.get('skip_cleanup', False) == True:
                # Some targets are used for manual power control of
                # infrastructure
                continue
            _systemd_keepalive(now)	# keepalive, this loop takes time
            owner = target.owner_get()
            if owner == None:
                _do_cleanup_released(target, who)
            else:
                _do_cleanup_acquired(target, owner, who)
        except ttbl.test_target_e as e:
            loge("%s" % e)
        except Exception as e:
            loge("%s: %s" % (target_id, e))
            traceback.print_exc()

# Another kludge: disable security warnings from request's urllib3
# vendored version. We know, we know. And probably there is a way to
# extract the ad-hoc SSL certificate info from within the Flask app.
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# This is one of the dirtiest kludges ever done
def cleanup_process_fn():
    global _systemd_watchdog_period
    # Cleanup tasks we can run in a separate process
    #
    # We also run a systemd watchdog (if systemd available and
    # configured) so systemd will restart the service if the cleanup
    # thread dies--happens sometimes, we don't know why
    # http://0pointer.de/blog/projects/watchdog.html
    if systemd_available and 'WATCHDOG_USEC' in os.environ:
        _systemd_watchdog_period =  float(os.environ['WATCHDOG_USEC']) / 1000000
        sleep_period = min(_systemd_watchdog_period / 2,
                           ttbl.config.target_max_idle / 2)
    else:
        _systemd_watchdog_period =  None
        sleep_period = ttbl.config.target_max_idle / 2
    logi("Clean up process [period %.2fs]" % sleep_period)
    cleanup_files_last = time.time()
    cleanup_targets_last = time.time()
    while True:
        time.sleep(sleep_period)
        t = time.time()
        logdl(8, "Scanning for idle targets")
        try:
            _systemd_keepalive(t)	# keepalive
            if t - cleanup_targets_last > ttbl.config.target_max_idle:
                _do_cleanup()
                cleanup_targets_last = t
            if t - cleanup_files_last > ttbl.config.cleanup_files_period:
                cleanup_files()
                cleanup_files_last = t
        except Exception as e:
            loge("Exception in clean thread: %s\n" % e)

main_pid = os.getpid()

# Define the login manager
login_manager = flask_login.LoginManager()

#! List of addresses to be considered local when they show in the
# remote_addr field of a request.
_local_addresses = set()
# Support for local users without having to go through local
# login--this is intended for running on single user workstations
# Start the daemon with --local-auth and just work as anonymous with
# full privilege.
#
# See https://flask-login.readthedocs.org/en/latest/#anonymous-users for
# the Flask details, but basically when flask needs to identify an
# Anonymous user, if the connection comes from one of the local ones,
# we just create an special anonymous user that has full privilege.
def _create_anonymous_user():
    if flask.request.remote_addr in _local_addresses:
        return ttbl.user_control.local_user()
    else:
        return flask_login.AnonymousUserMixin()

login_manager.anonymous_user = _create_anonymous_user

#    Connect *login_manager*'s operations to the implementations of the
#    user database defined here in :class:`User`.
@login_manager.user_loader
def load_user(userid):
    """
    Called by the login manager when looking for information about
    a given user ID
    """
    return ttbl.user_control.User.search_user(userid)

@login_manager.unauthorized_handler
def unauthorized():
    """
    Called by the login manager when a user is no authorized to
    do an operation
    """
    flask_logi_abort(400, "User unauthorized")

def auth_init(app):
    principals = flask_principal.Principal()
    principals.init_app(app)
    # The login manager provides session management for the Flask web
    # framework, handling login, logout and remembering user sessions
    # over extended periods of time (from
    # https://flask-login.readthedocs.org/en/latest/).
    global login_manager
    login_manager.init_app(app)
    # None means that the cookie will not contain information about
    # the IP address where the login came from. We want to be able to
    # carry our login information while the machine changes IP
    # address.
    # https://flask-login.readthedocs.io/en/latest/#session-protection
    login_manager.session_protection = None

    # Define this function here to connect FIXME how? This is kinda
    # confusing
    @flask_principal.identity_loaded.connect_via(app)
    def on_identity_loaded(sender, identity):
        """
        An identity has been loaded, add the information about the
        current user to the *identity* object
        """
        identity.user = flask_login.current_user

        # FIXME: we can do without the hasattr()? -- let's force
        # current_user to be at least a descentant of a certain base
        # class which enforces having those arguments
        if hasattr(flask_login.current_user, 'get_id'):
            identity.provides.add(flask_principal.UserNeed(
                flask_login.current_user.get_id()))

        if hasattr(flask_login.current_user, 'roles'):
            for role in flask_login.current_user.roles:
                identity.provides.add(flask_principal.RoleNeed(role))

local_auth = []

#
# Main
#
# Protect like this so this file can be easilly imported by the
# documentation generator with no side effects.
#
if __name__ == "__main__":

    # Drop the capabilities we don't really need but that we enabled
    # in the Ambient set so our helpers can inherit them. I might be
    # doing something wrong here, but I can't figure out how to
    # specify in systemd an inheritable set different than the ambient
    # set

    # Actually can't drop this -- I am definitely doing something
    # wrong and not sure what. If we drop this, then we can't read
    # /proc/PID/exe, which we need in commonl.process_alive() to
    # determine if the daemons have started properly -- instead it
    # will fail where 'Usually this means it has died while we
    # checked', which it shouldn't -- because we are running with the
    # same user/gid. Puzzled.
    #prctl.cap_effective.dac_read_search = False

    # Defaults
    # We want them here because we want these defaults to be overriden
    # by configuration to be overriden by command line options.
    host = "127.0.0.1"
    port = 5000

    arg_parser = argparse.ArgumentParser()
    commonl.cmdline_log_options(arg_parser)
    # Do it like this insead of adding a version to the main parser
    # because it will by default add adds -v as shortcut (when everyone and their grandma
    # knows -V is vor --version, -v for --verbose)
    arg_parser.add_argument(
        '-V', '--version',
        action = 'version', default = argparse.SUPPRESS,
        version = commonl.version_get(ttbl, "ttbd"),
        help= "show program's version number and exit")
    arg_parser.add_argument(
        "--config-path",
        action = "store", dest = "config_path",
        default = "~/.ttbd",
        help = "Path from where to load conf_*.py "
        "configuration files (in alphabetic order)")
    arg_parser.add_argument(
        "--config-file", "-c",
        action = "append", dest = "config_files", metavar = "CONFIG-FILE.py",
        # FIXME: s|/etc|system prefix from installation
        default = [ ],
        help = "Files to parse as configuration (this is used for testing, "
        "along with --config-path \"\"")
    arg_parser.add_argument(
        "--files-path", action = "store", default = "~/.ttbd/files",
        help = "directory where to store uploaded files [%(default)s]")
    arg_parser.add_argument(
        "--state-path", action = "store", default = "~/.ttbd/state",
        help = "Directory where to save state")
    arg_parser.add_argument(
        "--var-lib-path", "--state-persistent-path", dest = "var_lib_path",
        action = "store", default = "~/.ttbd/lib",
        help = "Directory where to save persistent state")
    arg_parser.add_argument(
        "--upload-max-size", action = "store", type = int,
        default = ttbl.config.upload_max_size,
        help = "Maximum (upload) file size (in bytes) [%(default)d]")
    arg_parser.add_argument(
        "--host", action = "store", default = None,
        help = "Hostname on which to listen [%(default)s]")
    arg_parser.add_argument(
        "--port", action = "store", type = int, default = None,
        help = "Port on which to listen [%d]" % port)
    arg_parser.add_argument(
        "--local-auth", metavar = "IP-ADDR", nargs = "?",
        action = "append", default = [],
        help = "Allow users as admins from the given IP "
        "addresses without caring; if no IP address is given, "
        "127.0.0.1 is assumed. Can be given multiple times with "
        "different addresses--no regexp or masks supported")
    arg_parser.add_argument(
        "--ssl-crt", default = None,
        help = "SSL certificate for HTTPS connections; if either "
        "(--ssl-key) not specified, it will use ad-hoc mode where "
        "it will be automatically generated")
    arg_parser.add_argument(
        "--ssl-key", default = None,
        help = "SSL key for HTTPS connections; see --ssl-crt")
    arg_parser.add_argument(
        "--no-ssl", dest = "ssl", action = "store_false", default = True,
        help = "Disable SSL support")
    arg_parser.add_argument(
        "--ssl-enabled-check-disregard", action = "store_true",
        default = False,
        help = "Do not check if SSL is enabled for certain things"
        "that shall be used only with it enabled, like LDAP")
    arg_parser.add_argument(
        "--target-max-idle", type = float, metavar = "SECONDS",
        action = "store", default = ttbl.config.target_max_idle,
        help = "What is the maximum amount of seconds a target can "
        "be idle before is auto-powered off (%(default).fs)")
    arg_parser.add_argument(
        "--system-wide", "-w", metavar = "NAME", action = "store",
        nargs = "?", type = str,
        const = "",	# If no arg, set to ""
        default = None,
        help = "Run in system wide mode, with an instance name (none by "
        "default, sets the config, state and file storage to "
        "{/etc/,/var/run,/var/cache}ttbd[-NAME]/")

    args = arg_parser.parse_args()

    if args.host != None:
        host = args.host
    if args.port != None:
        port = args.port

    log_format = "%(levelname)s %(module)s.%(funcName)s():%(lineno)d: %(message)s"
    log_format = commonl.log_format_compose(log_format, True)
    logging.basicConfig(format = log_format, level = args.level)

    # Cut down on verbosity from different packages
    logging.getLogger("requests").setLevel(logging.ERROR)
    logging.getLogger("flask").setLevel(logging.WARNING)
    logging.getLogger("werkzeug").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.ERROR)
    logging.getLogger("tornado.access").setLevel(logging.ERROR)

    ttbl.config.target_max_idle = args.target_max_idle

    if args.system_wide == None:
        ttbl.config.instance_suffix = ""
        ttbl.config.instance = ""
        # args.VAR stuff comes from settings on the argparser
        pass
    elif args.system_wide == "":
        ttbl.config.instance_suffix = ""
        ttbl.config.instance = ""
        args.config_path = "/etc/ttbd"
        args.files_path = "/var/cache/ttbd"
        args.state_path = "/var/run/ttbd"
        # State that stays through reboots
        args.var_lib_path = "/var/lib/ttbd"
    else:
        ttbl.config.instance = args.system_wide
        ttbl.config.instance_suffix = "-" + args.system_wide
        args.config_path = "/etc/ttbd" + ttbl.config.instance_suffix
        args.files_path = "/var/cache/ttbd" + ttbl.config.instance_suffix
        args.state_path = "/var/run/ttbd" + ttbl.config.instance_suffix
        # State that stays through reboots
        args.var_lib_path = os.path.join("/var/lib/ttbd", args.system_wide)

    os.umask(0o007)

    if not os.path.exists(args.var_lib_path):
        try:
            os.makedirs(args.var_lib_path, 0o2770)
        except OSError as e:
            if e.errno != errno.EEXIST:
                loge("%s: cannot create path: %s" % (args.var_lib_path, e))
                raise
    else:
        commonl.check_dir_writeable(args.var_lib_path, "storing state")

    # Define things ttbl.config needs for configuring targets
    ttbl.test_target.state_path = os.path.expanduser(args.state_path)
    ttbl.config.state_path = os.path.expanduser(args.state_path)
    ttbl.config.lib_path = os.path.expanduser(args.var_lib_path)
    if not os.path.isdir(ttbl.test_target.state_path):
        os.makedirs(ttbl.test_target.state_path, 0o2770)
    else:
        commonl.check_dir_writeable(ttbl.test_target.state_path,
                                    "storing state")
    args.state_path = ttbl.test_target.state_path

    args.config_path = os.path.expanduser(args.config_path)
    commonl.check_dir(args.config_path, "storing configuration")
    # FIXME: this has to be done as the options are specified?
    try:
        if args.config_path != [ "" ]:
            commonl.config_import([ args.config_path ], re.compile("^conf[-_].*.py$"))
        for config_file in args.config_files:
            commonl.config_import_file(config_file, "__main__")
        logd("configuration: loaded")
    except Exception:
        # config_import* failures mean we cannot read the config files
        # properly; they have already printed their messages, so just
        # exit here.
        sys.exit(1)

    # Allow local users access as admins? [--local-auth]
    # Command line goes after configuration file
    local_auth += args.local_auth
    if local_auth:
        import ttbl.auth_party
        # _local_addresses is used by _create_anonymous_user()
        for i, remote in enumerate(local_auth):
            if remote == None:
                _local_addresses.add("127.0.0.1")
            elif remote == "":	# Override support
                del _local_address[:]
            else:
                _local_addresses.add(remote)
        # Allow any local login/password to work, so we won't worry
        # about passwords when calling 'login'
        ttbl.config._authenticators.insert(0, ttbl.auth_party.authenticator_party_c(
            [ 'user', 'admin' ], local_addresses = _local_addresses))

    files_path = os.path.expanduser(args.files_path)
    ttbl.test_target.files_path = files_path
    commonl.check_dir_writeable(files_path, "storing uploaded files")

    # FIXME: needs a thread to clean up app.config['files_path']
    # enforcing LRU date and maximum size
    if ttbl.config.upload_max_size != args.upload_max_size:
        args.upload_max_size = ttbl.config.upload_max_size
    app.config['MAX_CONTENT_LENGTH'] = args.upload_max_size
    app.config['files_path'] = os.path.expanduser(args.files_path)
    app.config['state_path'] = ttbl.test_target.state_path
    ttbl.user_control.User.state_dir = args.var_lib_path
    app.config['REMEMBER_COOKIE_DURATION'] = datetime.timedelta(4)
    key_filename = os.path.join(args.var_lib_path, "session.key")
    try:
        with open(key_filename) as f:
            sk = cPickle.load(f)
            if type(sk) != str:
                raise Exception("Bad type in saved key")
            if len(sk) != 24:
                raise Exception("Bad length in saved key")
            logw("Reloaded key")
    except Exception as e:
        sk = os.urandom(24)
        logi("New key (because %s)" % e)
        umask_original = os.umask(0)
        commonl.rm_f(key_filename)
        try:
            fd = os.open(key_filename, os.O_WRONLY | os.O_CREAT | os.O_EXCL,
                         0o600)
        finally:
            os.umask(umask_original)
        with os.fdopen(fd, 'w') as f:
            cPickle.dump(sk, f, protocol = 2)

    app.secret_key = base64.b64encode(sk)

    # SSL config: default to at least TLS v1.2
    ssl_options = ssl.OP_NO_SSLv3 | ssl.OP_NO_SSLv2 | ssl.OP_NO_TLSv1
    if args.ssl == False:
        logi("SSL: disabled")
        ssl_context = None
    elif args.ssl_crt and args.ssl_key:
        if os.path.exists(args.ssl_crt) and os.path.exists(args.ssl_key):
            logw("SSL: using disabling CRT %s, key %s"
                 % (args.ssl_crt, args.ssl_key))
        else:
            raise Exception("(%s,%s): cannot open SSL required files"
                            % (args.ssl_crt, args.ssl_key))
        ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        ssl_context.options |= ssl_options
        ssl_context.load_cert_chain(args.ssl_crt, args.ssl_key)
    elif args.ssl == True:
        ttbl.config.ssl_enabled = args.ssl
        ttbl.config.ssl_enabled_check_disregard = \
                args.ssl_enabled_check_disregard
        logi("SSL: using adhoc context")
        ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        ssl_context.options |= ssl_options
        old_umask = os.umask(0o077)	# Create files go=
        try:
            cert_fn, pkey_fn = werkzeug.serving.make_ssl_devcert(
                os.path.join(args.state_path, "cert"))
        finally:
            os.umask(old_umask)
        ssl_context.load_cert_chain(cert_fn, pkey_fn)
        os.chmod(cert_fn, 0o640)	# Make the cert g+w
    else:
        raise RuntimeError("can't give --no-ssl and --ssl* options")

    #
    # Make this process a reaper
    #
    # Any child, grandchild or other descendant will be held by this
    # process if its parent dies (rather than init), so it can waitpid
    # on it and stuff. This is very Linux specific [for now].
    #
    # int prctl(int option, unsigned long arg2, unsigned long arg3,
    #           unsigned long arg4, unsigned long arg5);
    #
    # option PR_SET_CHILD_SUBREAPER (36, from linux/prctl.h)
    # arg2   1
    # arg*   unused
    #
    # prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0);
    #
    import ctypes
    libc = ctypes.CDLL("libc.so.6")
    r = libc.prctl(ctypes.c_int(36), ctypes.c_ulong(1), ctypes.c_ulong(0),
                   ctypes.c_ulong(0), ctypes.c_ulong(0))


    # Handle death of children, so they don't become zombies
    #
    # Only children that are registered as daemons are reaped (so they
    # don't become zombies). If we just ignore SIGCHLD, then
    # subprocess.check_call() and friends fail to catch commands that
    # fail to execute and return a non-zero exit code.
    #
    # Note that this list of daemons is PER-PROCESS; so still haven't
    # really solved what happens if we reap a daemon from a Python web
    # framework process that exited.
    def sigchld_handler(signum, frame):
        pid = ttblc.waitid_poll()
        if pid == -1 or pid == 0:
            return
        if ttbl.daemon_pid_check(pid):
            ttbl.daemon_pid_rm(pid)
            # Reap a daemon so it doesn't zombie
            r = os.waitpid(pid, os.WNOHANG)
            return
        # Not a daemon, don't reap it, let other do it
        return

    signal.signal(signal.SIGCHLD, sigchld_handler)

    # Ensure we are session leaders, so we can kill the whole group
    try:
        os.setsid()
    except OSError as e:
        if e.errno != errno.EPERM:
            raise
        # It is already a session leader...can ignore

    ttbl.cm_logger.setup()
    # Cleanup process...now this is quite very ugly...see _cleanup()
    cleanup_process = multiprocessing.Process(target = cleanup_process_fn)
    cleanup_process.daemon = True
    cleanup_process.start()

    # See authentication in the file's doc header
    auth_init(app)

    # Have flask send HTTP keep alives by implementing 1.1
    werkzeug.serving.WSGIRequestHandler.protocol_version = "HTTP/1.1"

    if True:
        # Tornado is single threaded, so not good for what we need
        from tornado.wsgi import WSGIContainer
        from tornado.httpserver import HTTPServer
        from tornado.ioloop import IOLoop

        http_server = HTTPServer(WSGIContainer(app), ssl_options = ssl_context)
        http_server.bind(port, address = host)
        # This might not be the real good way to do this, but our APIs
        # might block for a long time, so we start a crapload of
        # servers to be able to service more requests in paralell.
        http_server.start(ttbl.config.processes)
        sd_notify.notify("READY=1")
        IOLoop.instance().start()
    else:
        app.run(host = host, port = port, debug = True, use_reloader = False,
                processes = 10, ssl_context = ssl_context)

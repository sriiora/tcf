#! /usr/bin/python3
#
# Copyright (c) 2017 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
#

import glob
import os
import re
import site
import subprocess
import sys
import time

import distutils.command.install_data
import distutils.command.install_scripts

def mk_version_py(base_dir, version):
    """
    Create a version.py file in a directory with whichever version
    string is passed.
    """
    with open(os.path.join(base_dir, "version.py"), "w") as f:
        f.write("""\
#! /usr/bin/python3
#
# Copyright (c) 2017 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
#

# Generated by %s on %s
version_string = "%s"
""" % (__file__, time.asctime(), version))


# Run a post-install on installed data file replacing paths as we need
class _install_data(distutils.command.install_data.install_data):
    def run(self):
        # Workaround that install_data doesn't respect --prefix
        #
        # If prefix is given (via --user or via --prefix), then
        # extract it and add it to the paths in self.data_files;
        # otherwise, default to /usr/local.
        install = self.distribution.command_options.get('install', {})
        if 'user' in install:
            # this means --user was given
            self.prefix = site.getuserbase()
            sysconfigdir = os.path.join(self.prefix, 'etc')
        elif 'prefix' in install:
            # this means --prefix was given
            self.prefix = install.get('prefix', (None, None))[1]
            sysconfigdir = os.path.join(self.prefix, 'etc')
        else:
            self.prefix = 'usr'
            sysconfigdir = '/etc'
        new_data_files = []
        for entry in self.data_files:
            dest_path = entry[0].replace('@prefix@', self.prefix)
            dest_path = dest_path.replace('@sysconfigdir@', sysconfigdir)
            new_data_files.append((dest_path,) + entry[1:])
        self.data_files = new_data_files
        distutils.command.install_data.install_data.run(self)

# Run a post-install on installed data file replacing paths as we need
class _install_scripts(distutils.command.install_scripts.install_scripts):
    def run(self):
        # Workaround that install_data doesn't respect --prefix
        #
        # If prefix is given (via --user or via --prefix), then
        # extract it and add it to the paths in self.data_files;
        # otherwise, default to /usr/local.
        install = self.distribution.command_options.get('install', {})
        if 'user' in install:
            # this means --user was given
            sysconfigdir = "~/.local/etc"
            sharedir = "~/.local/share"
        elif 'prefix' in install:
            # this means --prefix was given
            prefix = install.get('prefix', (None, None))[1]
            sysconfigdir = os.path.join(prefix, "etc")
            sharedir = os.path.join(prefix, "etc")
        else:
            sysconfigdir = "/etc"
            sharedir = "/usr/share"
        distutils.command.install_scripts.install_scripts.run(self)
        for filename in self.outfiles:
            try:
                subprocess.check_call(
                    [
                        'sed', '-i',
                        '-e',
                        's|install_time_etc_tcf = .*$' \
                        '|install_time_etc_tcf = "' + sysconfigdir + '/tcf"|g',
                        '-e',
                        's|install_time_share_tcf = .*$' \
                        '|install_time_share_tcf = "' + sharedir + '/tcf"|g',
                        filename
                    ])
            except subprocess.CalledProcessError as e:
                sys.stderr.write("FAILED: sed failed\n")
                raise
            
# A glob that filters symlinks
def glob_no_symlinks(pathname):
    l = []
    for file_name in glob.iglob(pathname):
        if not os.path.islink(file_name):
            l.append(file_name)
    return l


# Find which version string to settle on
version = None
try:
    import tcfl.version
    version = tcfl.version.version_string
except:
    pass

if "VERSION" in os.environ:
    version = os.environ['VERSION']
elif version:
    """ already have something """
else:
    _src = os.path.abspath(__file__)
    _srcdir = os.path.dirname(_src)
    try:
        git_version = subprocess.check_output(
            "git describe --tags --always --abbrev=7 --dirty".split(),
            cwd = _srcdir, stderr = subprocess.PIPE)
        version = git_version.strip()
        if re.match("^v[0-9]+.[0-9]+", version.decode('UTF-8')):
            version = version[1:].decode('UTF-8')
    except subprocess.CalledProcessError as e:
        sys.stderr.write("FAILED: git failed: %s" % e.output)
        version = "vNA"
